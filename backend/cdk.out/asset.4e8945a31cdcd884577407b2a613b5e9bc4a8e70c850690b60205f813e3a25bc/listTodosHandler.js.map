{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lambda/data/listTodos.js","webpack:///./lambda/entities/Todo.js","webpack:///./lambda/handler/listTodosHandler.js","webpack:///./lambda/utils/base64.js","webpack:///./lambda/utils/errorWrapper.js","webpack:///./lambda/utils/errors.js","webpack:///./lambda/utils/generateId.js","webpack:///./lambda/utils/generateUpdateExpression.js","webpack:///./lambda/utils/responseMapper.js","webpack:///./node_modules/base-convert-int-array/index.js","webpack:///./node_modules/ksuid/base62.js","webpack:///./node_modules/ksuid/index.js","webpack:///external \"aws-sdk/clients/dynamodb\"","webpack:///external \"crypto\"","webpack:///external \"util\""],"names":[],"mappings":"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","file":"listTodosHandler.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lambda/handler/listTodosHandler.js\");\n","const{ DocumentClient } = require('aws-sdk/clients/dynamodb')\nconst dynamodb = new DocumentClient()\nconst{ encode, decode } = require('./../utils/base64')\n\nconst listTodos = async (todo, options={}) => {\n  try{\n    const{ limit= 20, nextToken } = options\n\n    let filterObj={\n      KeyConditionExpression: 'PK = :pk',\n      ExpressionAttributeValues: {\n        ':pk': todo.key()['PK']\n      }\n    }\n\n    if(nextToken){\n      filterObj.ExclusiveStartKey = decode(nextToken)\n    }\n    if(limit){\n      filterObj.Limit= limit\n    }\n\n    const response = await dynamodb.query({\n      TableName: process.env['TodosTable'],\n      ProjectionExpression: 'id, #text, completed',\n      ...filterObj,\n      ExpressionAttributeNames: {\n        // reserved word\n        '#text': 'text'\n      }\n    }).promise()\n\n    return{\n      todos: response.Items,\n      nextToken: encode(response.LastEvaluatedKey)\n    }\n  } catch(error) {\n    console.log(error)\n    return{\n      error: 'Could not get todos'\n    }\n  }\n}\n\nmodule.exports = {\n  listTodos\n}","const{ generateId } = require('./../utils/generateId')\nconst{ generateUpdateExpression } = require('./../utils/generateUpdateExpression')\n\nclass Todo {\n  constructor(userId, { id, ...todoData }={}) {\n    this.userId = userId\n    this.id = id ? id : generateId()\n\n    this.todoData = todoData\n  }\n\n  key() {\n    return{\n      'PK': `Merchant#${this.userId}#Todo`,\n      'SK': `Todo#${this.id}`\n    }\n  }\n\n  // for put\n  toItem() {\n    return{\n      ...this.key(),\n      id: this.id,\n      userId: this.userId,\n      EntityType: 'Todo',\n      ...this.todoData\n    }\n  }\n\n  // for update\n  toUpdateItem(){\n    if(Object.keys(this.todoData).length === 0)\n      throw new Error('Update object should not be empty')\n\n    return generateUpdateExpression(this.todoData)\n  }\n    \n}\n\nmodule.exports = {\n  Todo\n}","const{ listTodos } = require('../data/listTodos')\nconst{ Todo } = require('../entities/Todo')\nconst{ ErrorWrapper } = require('../utils/errorWrapper')\nconst{ responseMapper } = require('./../utils/responseMapper')\n\nmodule.exports.handler = async (event, context, callback ) => {\n  try{\n    console.log(JSON.stringify(event))\n\n    const userId = event.requestContext.authorizer.claims.sub\n    \n    const listTodosOptions = {}\n\n    const todoInstance = new Todo(userId)\n\n    const{ todos, nextToken, error } = await listTodos(todoInstance, listTodosOptions)\n    \n    if(error)\n      throw new Error(error)\n\n    let response = {\n      todos,\n      nextToken\n    }\n\n    return responseMapper(200, response)\n    \n  } catch(err){\n    console.log(err)\n    return callback(ErrorWrapper(err))\n  }\n}","// use case: \n// when you use dynamo query for pagination it would return the last key it queried, imagine this obj at url\n// ?pagination={pk: \"325\", sk:325} WEIRD! \n// so we encode the tokens when returned to the user and decode the tokens we get from the user (just like appsync dynamo)\n\nconst encode = (item) => {\n  if(!item){\n    return null\n  }\n  return Buffer.from(JSON.stringify(item)).toString('base64')\n}\n\nconst decode = (item) => {\n  return JSON.parse(Buffer.from(item, 'base64').toString())\n}\n\nmodule.exports = {\n  encode,\n  decode\n}","const{ errors } = require('./errors')\nconst{ responseMapper } = require('./responseMapper')\n\nconst ErrorWrapper = (errorKey) => {\n  try{\n    let error = errors[errorKey.message]\n\n    if(!error){\n      // in case errorKey isn't correct\n      throw new Error('Bad Key')\n    }\n    return errorResponseMapper(error)\n\n  } catch(e){\n    console.log('BAD Key', errorKey, 'error', e)\n    // default error\n    return errorResponseMapper(errors['GeneralError'])\n  }\n}\n\nconst errorResponseMapper = (error) =>{\n  return responseMapper(error.statusCode, error)\n}\n\nmodule.exports = {\n  ErrorWrapper,\n}\n","// errorKey => can be used as keys on i18n (on client side)\n// message => for information only\n\nconst errors = {\n  GeneralError: {\n    message: 'Something went wrong! (contact backend)',\n    errorKey: 'GeneralError',\n    statusCode: 500\n  },\n  TodoGeneralError: {\n    message: 'Todo: Something went wrong!',\n    errorKey: 'TodoGeneralError',\n    statusCode: 500\n  },\n}\n\nmodule.exports = { errors }\n","const crypto = require('crypto')\nconst KSUID = require('ksuid')\n\nconst generateId = (date = new Date()) => {\n  const payload = crypto.randomBytes(16)\n  return KSUID.fromParts(date.getTime(), payload).string\n}\n\nmodule.exports = {\n  generateId\n}","// takes updatePayload like {\n//   name: \"test\"\n// } and converts it to dynamo expression\n// on db.update({  pass ...generateUpdateExpression\n\n// remove payload contains keys you want to delete like [\"gsi1pk\", \"gsi1sk\"]\nconst generateUpdateExpression = (updatePayload, removePayload = []) => {\n  let UpdateExpression = 'SET '\n  let ExpressionAttributeValues = {}\n  let ExpressionAttributeNames = {}\n\n  const keys = Object.keys(updatePayload)\n  for(const key of keys) {\n    UpdateExpression += `#${key}=:${key},`\n    ExpressionAttributeValues[`:${key}`] = updatePayload[key]\n    ExpressionAttributeNames[`#${key}`] = key\n  }\n  \n  UpdateExpression=UpdateExpression.slice(0, -1)\n\n  if(removePayload.length!==0){\n    UpdateExpression += ' REMOVE '\n    removePayload.map(removeKey=> UpdateExpression += `${removeKey},`)\n    UpdateExpression=UpdateExpression.slice(0, -1)\n  }\n\n  console.log(UpdateExpression)\n  return{\n    UpdateExpression,\n    ExpressionAttributeNames,\n    ExpressionAttributeValues\n  }\n}\n\nmodule.exports = {\n  generateUpdateExpression\n}","const responseMapper = (status, error) =>{\n  return{\n    statusCode: status, \n    body: JSON.stringify(error),\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': '*',\n    }\n  }\n}\n\nmodule.exports = {\n  responseMapper,\n}\n","'use strict'\n\nconst maxLength = (array, from, to) => Math.ceil(array.length * Math.log2(from) / Math.log2(to))\n\nfunction baseConvertIntArray (array, {from, to, fixedLength = null}) {\n  const length = fixedLength === null ? maxLength(array, from, to) : fixedLength\n  const result = new Array(length)\n\n  // Each iteration prepends the resulting value, so start the offset at the end.\n  let offset = length\n  let input = array\n  while (input.length > 0) {\n    if (offset === 0) {\n      throw new RangeError(`Fixed length of ${fixedLength} is too small, expected at least ${maxLength(array, from, to)}`)\n    }\n\n    const quotients = []\n    let remainder = 0\n\n    for (const digit of input) {\n      const acc = digit + remainder * from\n      const q = Math.floor(acc / to)\n      remainder = acc % to\n\n      if (quotients.length > 0 || q > 0) {\n        quotients.push(q)\n      }\n    }\n\n    result[--offset] = remainder\n    input = quotients\n  }\n\n  // Trim leading padding, unless length is fixed.\n  if (fixedLength === null) {\n    return offset > 0 ? result.slice(offset) : result\n  }\n\n  // Fill in any holes in the result array.\n  while (offset > 0) {\n    result[--offset] = 0\n  }\n  return result\n}\nmodule.exports = baseConvertIntArray\n","'use strict'\nconst baseConvertIntArray = require('base-convert-int-array')\n\nconst CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\nfunction encode (buffer, fixedLength) {\n  return baseConvertIntArray(buffer, { from: 256, to: 62, fixedLength })\n    .map(value => CHARS[value])\n    .join('')\n}\nexports.encode = encode\n\nfunction decode (string, fixedLength) {\n  // Optimization from https://github.com/andrew/base62.js/pull/31.\n  const input = Array.from(string, char => {\n    const charCode = char.charCodeAt(0)\n    if (charCode < 58) return charCode - 48\n    if (charCode < 91) return charCode - 55\n    return charCode - 61\n  })\n  return Buffer.from(baseConvertIntArray(input, { from: 62, to: 256, fixedLength }))\n}\nexports.decode = decode\n","'use strict'\nconst { randomBytes } = require('crypto')\nconst { inspect: { custom: customInspectSymbol }, promisify } = require('util')\nconst base62 = require('./base62')\n\nconst asyncRandomBytes = promisify(randomBytes)\n\n// KSUID's epoch starts more recently so that the 32-bit number space gives a\n// significantly higher useful lifetime of around 136 years from March 2014.\n// This number (14e11) was picked to be easy to remember.\nconst EPOCH_IN_MS = 14e11\n\nconst MAX_TIME_IN_MS = 1e3 * (2 ** 32 - 1) + EPOCH_IN_MS\n\n// Timestamp is a uint32\nconst TIMESTAMP_BYTE_LENGTH = 4\n\n// Payload is 16-bytes\nconst PAYLOAD_BYTE_LENGTH = 16\n\n// KSUIDs are 20 bytes when binary encoded\nconst BYTE_LENGTH = TIMESTAMP_BYTE_LENGTH + PAYLOAD_BYTE_LENGTH\n\n// The length of a KSUID when string (base62) encoded\nconst STRING_ENCODED_LENGTH = 27\n\nconst TIME_IN_MS_ASSERTION = `Valid KSUID timestamps must be in milliseconds since ${new Date(0).toISOString()},\n  no earlier than ${new Date(EPOCH_IN_MS).toISOString()} and no later than ${new Date(MAX_TIME_IN_MS).toISOString()}\n`.trim().replace(/(\\n|\\s)+/g, ' ').replace(/\\.000Z/g, 'Z')\n\nconst VALID_ENCODING_ASSERTION = `Valid encoded KSUIDs are ${STRING_ENCODED_LENGTH} characters`\n\nconst VALID_BUFFER_ASSERTION = `Valid KSUID buffers are ${BYTE_LENGTH} bytes`\n\nconst VALID_PAYLOAD_ASSERTION = `Valid KSUID payloads are ${PAYLOAD_BYTE_LENGTH} bytes`\n\nfunction fromParts (timeInMs, payload) {\n  const timestamp = Math.floor((timeInMs - EPOCH_IN_MS) / 1e3)\n  const timestampBuffer = Buffer.allocUnsafe(TIMESTAMP_BYTE_LENGTH)\n  timestampBuffer.writeUInt32BE(timestamp, 0)\n\n  return Buffer.concat([timestampBuffer, payload], BYTE_LENGTH)\n}\n\nconst bufferLookup = new WeakMap()\n\nclass KSUID {\n  constructor (buffer) {\n    if (!KSUID.isValid(buffer)) {\n      throw new TypeError(VALID_BUFFER_ASSERTION)\n    }\n\n    bufferLookup.set(this, buffer)\n    Object.defineProperty(this, 'buffer', {\n      enumerable: true,\n      get () { return Buffer.from(buffer) }\n    })\n  }\n\n  get raw () {\n    return Buffer.from(bufferLookup.get(this).slice(0))\n  }\n\n  get date () {\n    return new Date(1e3 * this.timestamp + EPOCH_IN_MS)\n  }\n\n  get timestamp () {\n    return bufferLookup.get(this).readUInt32BE(0)\n  }\n\n  get payload () {\n    const payload = bufferLookup.get(this).slice(TIMESTAMP_BYTE_LENGTH, BYTE_LENGTH)\n    return Buffer.from(payload)\n  }\n\n  get string () {\n    const encoded = base62.encode(bufferLookup.get(this), STRING_ENCODED_LENGTH)\n    return encoded.padStart(STRING_ENCODED_LENGTH, '0')\n  }\n\n  compare (other) {\n    if (!bufferLookup.has(other)) {\n      return 0\n    }\n\n    return bufferLookup.get(this).compare(bufferLookup.get(other), 0, BYTE_LENGTH)\n  }\n\n  equals (other) {\n    return this === other || (bufferLookup.has(other) && this.compare(other) === 0)\n  }\n\n  toString () {\n    return `${this[Symbol.toStringTag]} { ${this.string} }`\n  }\n\n  [customInspectSymbol] () {\n    return this.toString()\n  }\n\n  static async random (time = Date.now()) {\n    const payload = await asyncRandomBytes(PAYLOAD_BYTE_LENGTH)\n    return new KSUID(fromParts(Number(time), payload))\n  }\n\n  static randomSync (time = Date.now()) {\n    const payload = randomBytes(PAYLOAD_BYTE_LENGTH)\n    return new KSUID(fromParts(Number(time), payload))\n  }\n\n  static fromParts (timeInMs, payload) {\n    if (!Number.isInteger(timeInMs) || timeInMs < EPOCH_IN_MS || timeInMs > MAX_TIME_IN_MS) {\n      throw new TypeError(TIME_IN_MS_ASSERTION)\n    }\n    if (!Buffer.isBuffer(payload) || payload.byteLength !== PAYLOAD_BYTE_LENGTH) {\n      throw new TypeError(VALID_PAYLOAD_ASSERTION)\n    }\n\n    return new KSUID(fromParts(timeInMs, payload))\n  }\n\n  static isValid (buffer) {\n    return Buffer.isBuffer(buffer) && buffer.byteLength === BYTE_LENGTH\n  }\n\n  static parse (string) {\n    if (string.length !== STRING_ENCODED_LENGTH) {\n      throw new TypeError(VALID_ENCODING_ASSERTION)\n    }\n\n    const decoded = base62.decode(string, BYTE_LENGTH)\n    if (decoded.byteLength === BYTE_LENGTH) {\n      return new KSUID(decoded)\n    }\n\n    const buffer = Buffer.allocUnsafe(BYTE_LENGTH)\n    const padEnd = BYTE_LENGTH - decoded.byteLength\n    buffer.fill(0, 0, padEnd)\n    decoded.copy(buffer, padEnd)\n    return new KSUID(buffer)\n  }\n}\nObject.defineProperty(KSUID.prototype, Symbol.toStringTag, { value: 'KSUID' })\n// A string-encoded maximum value for a KSUID\nObject.defineProperty(KSUID, 'MAX_STRING_ENCODED', { value: 'aWgEPTl1tmebfsQzFP4bxwgy80V' })\n// A string-encoded minimum value for a KSUID\nObject.defineProperty(KSUID, 'MIN_STRING_ENCODED', { value: '000000000000000000000000000' })\n\nmodule.exports = KSUID\n","module.exports = require(\"aws-sdk/clients/dynamodb\");","module.exports = require(\"crypto\");","module.exports = require(\"util\");"],"sourceRoot":""}